<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Damage Log Visualizer</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      h1 {
        text-align: center;
        margin-bottom: 20px;
      }
      #controls {
        text-align: center;
        margin-bottom: 10px;
      }
      #filters {
        text-align: center;
        margin-bottom: 10px;
      }
      #chart_div {
        width: 100%;
        height: 400px;
        margin-bottom: 10px;
        margin: 0 auto;
      }
      #summaryTotals {
        text-align: center;
        margin-top: 20px;
      }
      button {
        margin: 0 5px;
        padding: 5px 10px;
        font-size: 1rem;
      }
      label {
        margin: 0 10px;
        font-size: 1rem;
      }
    </style>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script>
      // Load the Google Charts package.
      google.charts.load("current", { packages: ["corechart"] });
      google.charts.setOnLoadCallback(init);

      // Map team names to colors.
      const teamColors = {
        PlayerRed: "red",
        PlayerBlue: "blue",
      };

      let currentMatchData = []; // Array of matches; each match is an array of events.
      let matchIndex = 0;
      let currentDataTable = null;
      let currentSeriesKeys = null;

      // When filters change, re-draw the current match.
      function attachFilterListeners() {
        document
          .querySelectorAll('input[name="filter"]')
          .forEach((checkbox) => {
            checkbox.addEventListener("change", () => {
              // Re-display current match using filters.
              displayMatchData(currentMatchData[matchIndex]);
            });
          });
      }

      function init() {
        document
          .getElementById("fileInput")
          .addEventListener("change", handleFileSelect, false);
        document
          .getElementById("nextButton")
          .addEventListener("click", showNextMatch);
        document
          .getElementById("prevButton")
          .addEventListener("click", showPrevMatch);
        window.addEventListener("resize", onWindowResize);
        attachFilterListeners();
      }

      // Parse the log file text into matches.
      // A match is defined as a series of damage events ending with a "Match Results" line.
      function parseLog(text) {
        const lines = text.split("\n");
        const matches = [];
        let matchData = [];
        let matchActive = false;

        // Regular expressions for send and receive lines.
        const sendRegex =
          /\[(.*?)\].*Match damage send: Id: \d+ Type: (\w+) type: (\w+) region: (\w+) movement: (\w*) weakPoint: (\w*) amount: ([\d.]+).*closest neutral corner: (\w+)/;
        const receiveRegex =
          /\[(.*?)\].*Match damage received: Id: \d+ Type: (\w+), type: (\w+) region: (\w+) weakPoint: (\w*) movementType: (\w*) amount: ([\d.]+)/;
        const resultsRegex = /Match Results:/;

        // Helper: Convert HH:MM:SS.mmm to seconds.
        function timeToSeconds(tStr) {
          const parts = tStr.split(":");
          const hours = parseInt(parts[0], 10);
          const minutes = parseInt(parts[1], 10);
          const secParts = parts[2].split(".");
          const seconds = parseInt(secParts[0], 10);
          const millis = parseInt(secParts[1] || "0", 10);
          return hours * 3600 + minutes * 60 + seconds + millis / 1000;
        }

        let firstTimeSeconds = null;
        for (const line of lines) {
          let match;
          let timestamp, team, damageType, region, weakPoint, movement, amount;
          if ((match = sendRegex.exec(line))) {
            matchActive = true;
            timestamp = match[1];
            team = match[2];
            damageType = match[3];
            region = match[4];
            movement = match[5];
            weakPoint = match[6] || "None";
            amount = parseFloat(match[7]);
          } else if ((match = receiveRegex.exec(line))) {
            matchActive = true;
            timestamp = match[1];
            team = match[2];
            damageType = match[3];
            region = match[4];
            weakPoint = match[5] || "None";
            movement = match[6];
            amount = parseFloat(match[7]);
          } else if (resultsRegex.test(line)) {
            // End of current match.
            if (matchActive && matchData.length > 0) {
              matches.push(matchData);
              matchData = [];
            }
            matchActive = false;
            continue;
          } else {
            continue; // Skip lines that don't match.
          }

          // Convert timestamp to seconds offset.
          const tSeconds = timeToSeconds(timestamp);
          if (firstTimeSeconds === null) {
            firstTimeSeconds = tSeconds;
          }
          const timeOffset = tSeconds - firstTimeSeconds;

          // Determine category.
          // "guard": damageType === "None"
          // "strike": damageType === "Hit"
          // "knockdown": any other damageType.
          let category;
          if (damageType === "None") {
            category = "guard";
          } else if (damageType === "Hit") {
            category = "strike";
          } else {
            category = "knockdown";
          }

          // Build tooltip including knockdown info.
          const knockdownText = category === "knockdown" ? "Yes" : "No";
          const tooltip =
            "Time: " +
            timestamp +
            "\nTeam: " +
            team +
            "\nType: " +
            damageType +
            "\nWeakPoint: " +
            weakPoint +
            "\nKnockdown: " +
            knockdownText +
            "\nAmount: " +
            amount;

          matchData.push({
            time: timeOffset,
            amount: amount,
            team: team,
            damageType: damageType,
            region: region,
            weakPoint: weakPoint,
            movement: movement,
            category: category,
            tooltip: tooltip,
          });
        }
        if (matchData.length > 0) {
          matches.push(matchData);
        }
        return matches;
      }

      // Filter the match data based on current filter selections.
      function filterMatchData(matchData) {
        const showGuard = document.getElementById("filterGuard").checked;
        const showStrike = document.getElementById("filterStrike").checked;
        const showKnockdown = document.getElementById("filterKnockdown").checked;

        return matchData.filter((pt) => {
          if (pt.category === "guard" && !showGuard) return false;
          if (pt.category === "strike" && !showStrike) return false;
          if (pt.category === "knockdown" && !showKnockdown) return false;
          return true;
        });
      }

      // Group data points into series based on team and category.
      function groupData(dataPoints) {
        const seriesData = {};
        dataPoints.forEach((pt) => {
          const key = pt.team + "_" + pt.category;
          if (!seriesData[key]) {
            seriesData[key] = [];
          }
          seriesData[key].push(pt);
        });
        return seriesData;
      }

      // Build a data table for Google Charts from the series data.
      function buildDataTable(seriesData) {
        const timeSet = new Set();
        for (const key in seriesData) {
          seriesData[key].forEach((pt) => timeSet.add(pt.time));
        }
        const times = Array.from(timeSet).sort((a, b) => a - b);

        const seriesKeys = Object.keys(seriesData).sort();
        const dataTable = new google.visualization.DataTable();
        dataTable.addColumn("number", "Time (s)");
        seriesKeys.forEach((key) => {
          dataTable.addColumn("number", key);
          dataTable.addColumn({ type: "string", role: "tooltip", p: { html: true } });
        });

        const seriesLookup = {};
        seriesKeys.forEach((key) => {
          seriesLookup[key] = {};
          seriesData[key].forEach((pt) => {
            seriesLookup[key][pt.time] = { value: pt.amount, tooltip: pt.tooltip };
          });
        });

        const rows = times.map((t) => {
          const row = [t];
          seriesKeys.forEach((key) => {
            if (seriesLookup[key][t]) {
              row.push(seriesLookup[key][t].value);
              row.push(seriesLookup[key][t].tooltip);
            } else {
              row.push(null);
              row.push(null);
            }
          });
          return row;
        });
        dataTable.addRows(rows);
        return { dataTable, seriesKeys, times };
      }

      // Draw the chart using Google Charts ScatterChart.
      function drawChart(dataTable, seriesKeys) {
        const seriesOptions = {};
        seriesKeys.forEach((key, index) => {
          const parts = key.split("_");
          const team = parts[0];
          const category = parts[1];
          let color = teamColors[team] || "black";
          let pointShape = "circle";
          const seriesOpts = {
            color: color,
            pointSize: 10,
          };
          if (category === "guard") {
            pointShape = "square";
          } else if (category === "strike") {
            pointShape = "triangle";
          } else if (category === "knockdown") {
            pointShape = "diamond";
            color = team === "PlayerRed" ? "darkred" : "darkblue";
            seriesOpts.color = color;
          }
          seriesOpts.pointShape = pointShape;
          seriesOptions[index] = seriesOpts;
        });

        const options = {
          title: "Damage Over Time",
          hAxis: { title: "Time (s)" },
          vAxis: { title: "Damage Amount" },
          tooltip: { isHtml: false },
          pointSize: 10,
          series: seriesOptions,
          legend: { position: "bottom", maxLines: 2 },
          chartArea: { top: 50, left: 50, width: "80%", height: "70%" },
        };

        const chart = new google.visualization.ScatterChart(document.getElementById("chart_div"));
        chart.draw(dataTable, options);
      }

      // Display match data (chart and summary totals).
      function displayMatchData(matchData) {
        // Apply filters.
        const filteredData = filterMatchData(matchData);
        const seriesData = groupData(filteredData);
        const { dataTable, seriesKeys } = buildDataTable(seriesData);
        currentDataTable = dataTable;
        currentSeriesKeys = seriesKeys;
        drawChart(dataTable, seriesKeys);
        displaySummaryTotals(filteredData);
      }

      // Generate and display summary totals for each team.
      function displaySummaryTotals(matchData) {
        let summary = { PlayerRed: { damage: 0, hits: 0 }, PlayerBlue: { damage: 0, hits: 0 } };
        matchData.forEach((pt) => {
          if (pt.team === "PlayerRed" || pt.team === "PlayerBlue") {
            summary[pt.team].damage += pt.amount;
            summary[pt.team].hits += 1;
          }
        });
        const summaryDiv = document.getElementById("summaryTotals");
        summaryDiv.innerHTML = `
          <h3>Summary Totals</h3>
          <p style="color: red;"><strong>Red:</strong> Total Damage: ${summary.PlayerRed.damage.toFixed(
            2
          )}, Total Hits: ${summary.PlayerRed.hits}</p>
          <p style="color: blue;"><strong>Blue:</strong> Total Damage: ${summary.PlayerBlue.damage.toFixed(
            2
          )}, Total Hits: ${summary.PlayerBlue.hits}</p>
        `;
      }

      // Event handlers for navigation.
      function showNextMatch() {
        if (matchIndex < currentMatchData.length - 1) {
          matchIndex++;
          displayMatchData(currentMatchData[matchIndex]);
          updateNavButtons();
        } else {
          alert("No more matches available.");
        }
      }

      function showPrevMatch() {
        if (matchIndex > 0) {
          matchIndex--;
          displayMatchData(currentMatchData[matchIndex]);
          updateNavButtons();
        } else {
          alert("Already at the first match.");
        }
      }

      function updateNavButtons() {
        document.getElementById("prevButton").disabled = matchIndex === 0;
        document.getElementById("nextButton").disabled =
          matchIndex === currentMatchData.length - 1;
      }

      // Redraw the current chart on window resize.
      function onWindowResize() {
        if (currentDataTable && currentSeriesKeys) {
          drawChart(currentDataTable, currentSeriesKeys);
        }
      }

      // Handler for file selection.
      function handleFileSelect(evt) {
        const file = evt.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          const text = e.target.result;
          currentMatchData = parseLog(text);
          if (currentMatchData.length > 0) {
            matchIndex = 0;
            displayMatchData(currentMatchData[matchIndex]);
            updateNavButtons();
          } else {
            alert("No valid match data found.");
          }
        };
        reader.readAsText(file);
      }
    </script>
  </head>
  <body>
    <h1>Damage Log Visualizer</h1>
    <div id="controls">
      <input type="file" id="fileInput" accept=".txt" />
      <br /><br />
      <button id="prevButton" disabled>Previous Match</button>
      <button id="nextButton" disabled>Next Match</button>
    </div>
    <div id="filters">
      <label>
        <input type="checkbox" id="filterGuard" name="filter" checked />
        Guard
      </label>
      <label>
        <input type="checkbox" id="filterStrike" name="filter" checked />
        Strike
      </label>
      <label>
        <input type="checkbox" id="filterKnockdown" name="filter" checked />
        Knockdown
      </label>
    </div>
    <div id="chart_div"></div>
    <div id="summaryTotals"></div>
  </body>
</html>
